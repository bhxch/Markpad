use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let grammars_dir = Path::new("grammars");
    
    if !grammars_dir.exists() {
        println!("cargo:warning=Grammars directory not found. Run python scripts/prepare_grammars.py first");
        tauri_build::build();
        return;
    }
    
    // List of grammars: (name, directory, subpath)
    let grammars = vec![
        ("rust", "rust", ""),
        ("javascript", "javascript", ""),
        ("python", "python", ""),
        ("typescript", "typescript", "typescript"),
        ("tsx", "tsx", "tsx"),
        ("go", "go", ""),
        ("c", "c", ""),
        ("cpp", "cpp", ""),
        ("java", "java", ""),
        ("json", "json", ""),
        ("html", "html", ""),
        ("css", "css", ""),
        ("bash", "bash", ""),
        ("yaml", "yaml", ""),
        ("toml", "toml", ""),
        ("markdown", "markdown", ""),
    ];
    
    for (name, dir, subpath) in &grammars {
        compile_grammar(name, &grammars_dir.join(dir), subpath);
    }
    
    generate_ffi_module(&grammars);
    
    tauri_build::build();
}

fn compile_grammar(name: &str, grammar_dir: &Path, subpath: &str) {
    let src_dir = if subpath.is_empty() {
        grammar_dir.join("src")
    } else {
        grammar_dir.join(subpath).join("src")
    };
    
    if !src_dir.exists() {
        println!("cargo:warning=Grammar src directory not found for {} at {:?}", name, src_dir);
        return;
    }
    
    let parser_c = src_dir.join("parser.c");
    
    if !parser_c.exists() {
        println!("cargo:warning=parser.c not found for grammar {}", name);
        return;
    }
    
    println!("cargo:rerun-if-changed={}", parser_c.display());
    
    // Check for scanner files (C or C++)
    let scanner_c = src_dir.join("scanner.c");
    let scanner_cc = src_dir.join("scanner.cc");
    let schema_cc = src_dir.join("schema.generated.cc");
    
    // Build parser with C compiler
    let mut build = cc::Build::new();
    build
        .file(&parser_c)
        .include(&src_dir)
        .include(grammar_dir)
        .warnings(false);
    
    if scanner_c.exists() {
        println!("cargo:rerun-if-changed={}", scanner_c.display());
        build.file(&scanner_c);
    }
    
    build.compile(&format!("tree_sitter_{}", name.replace("-", "_")));
    
    // If there are C++ files, compile them separately with C++ compiler
    if scanner_cc.exists() || schema_cc.exists() {
        println!("cargo:rerun-if-changed={}", scanner_cc.display());
        let mut cpp_build = cc::Build::new();
        cpp_build
            .cpp(true)
            .include(&src_dir)
            .include(grammar_dir)
            .warnings(false);
        
        if scanner_cc.exists() {
            println!("cargo:rerun-if-changed={}", scanner_cc.display());
            cpp_build.file(&scanner_cc);
        }
        if schema_cc.exists() {
            println!("cargo:rerun-if-changed={}", schema_cc.display());
            cpp_build.file(&schema_cc);
        }
        
        cpp_build.compile(&format!("tree_sitter_{}_cpp", name.replace("-", "_")));
    }
    
    println!("cargo:rustc-link-lib=static=tree_sitter_{}", name.replace("-", "_"));
}

fn generate_ffi_module(grammars: &[(&str, &str, &str)]) {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("grammar_ffi.rs");
    
    let mut content = String::new();
    content.push_str("// Auto-generated by build.rs\n");
    content.push_str("// FFI declarations for tree-sitter grammars\n\n");
    content.push_str("use tree_sitter_language::LanguageFn;\n\n");
    
    for (name, _, _) in grammars {
        let fn_name = format!("tree_sitter_{}", name.replace("-", "_"));
        content.push_str(&format!(
            "extern \"C\" {{ fn {}() -> *const (); }}\n",
            fn_name
        ));
    }
    
    content.push_str("\n/// Get the language function for a grammar by name.\n");
    content.push_str("pub fn get_language(name: &str) -> Option<tree_sitter::Language> {\n");
    content.push_str("    match name {\n");
    
    for (name, _, _) in grammars {
        let fn_name = format!("tree_sitter_{}", name.replace("-", "_"));
        content.push_str(&format!(
            "        \"{}\" => Some(unsafe {{ LanguageFn::from_raw({}) }}.into()),\n",
            name, fn_name
        ));
    }
    
    content.push_str("        _ => None,\n");
    content.push_str("    }\n");
    content.push_str("}\n");
    
    fs::write(&dest_path, &content).unwrap();
    println!("cargo:rerun-if-changed=build.rs");
}
