#!/usr/bin/env python3
"""
Generate build.rs and registry.rs for all grammars.
"""

import json
import re
from pathlib import Path

# Paths
GRAMMAR_INFO = Path(__file__).parent.parent / "src-tauri" / "grammar_info.json"
BUILD_RS = Path(__file__).parent.parent / "src-tauri" / "build.rs"
REGISTRY_RS = Path(__file__).parent.parent / "src-tauri" / "src" / "highlight" / "registry.rs"

# Common languages to include (reduces binary size significantly)
# Set to None to include all languages
COMMON_LANGUAGES = None  # Include all languages


def sanitize_name(name: str) -> str:
    """Convert language name to valid Rust identifier."""
    return name.replace("-", "_").replace(".", "_")


def generate_build_rs(grammars: dict):
    """Generate build.rs content."""
    lines = [
        'use std::env;',
        'use std::fs;',
        'use std::path::Path;',
        '',
        'fn main() {',
        '    let grammars_dir = Path::new("grammars");',
        '    ',
        '    if !grammars_dir.exists() {',
        '        println!("cargo:warning=Grammars directory not found. Run python scripts/download_grammars_git.py first");',
        '        tauri_build::build();',
        '        return;',
        '    }',
        '    ',
        '    // List of grammars: (name, directory, subpath)',
        '    let grammars: Vec<(&str, &str, &str)> = vec![',
    ]
    
    for name, info in sorted(grammars.items()):
        subpath = info.get("subpath", "")
        lines.append(f'        ("{name}", "{name}", "{subpath}"),')
    
    lines.extend([
        '    ];',
        '    ',
        '    for (name, dir, subpath) in &grammars {',
        '        compile_grammar(name, &grammars_dir.join(dir), subpath);',
        '    }',
        '    ',
        '    generate_ffi_module(&grammars);',
        '    ',
        '    tauri_build::build();',
        '}',
        '',
        'fn compile_grammar(name: &str, grammar_dir: &Path, subpath: &str) {',
        '    let src_dir = if subpath.is_empty() {',
        '        grammar_dir.join("src")',
        '    } else {',
        '        grammar_dir.join(subpath).join("src")',
        '    };',
        '    ',
        '    if !src_dir.exists() {',
        '        println!("cargo:warning=Grammar src directory not found for {} at {:?}", name, src_dir);',
        '        return;',
        '    }',
        '    ',
        '    let parser_c = src_dir.join("parser.c");',
        '    ',
        '    if !parser_c.exists() {',
        '        println!("cargo:warning=parser.c not found for grammar {}", name);',
        '        return;',
        '    }',
        '    ',
        '    println!("cargo:rerun-if-changed={}", parser_c.display());',
        '    ',
        '    // Check for scanner files (C or C++)',
        '    let scanner_c = src_dir.join("scanner.c");',
        '    let scanner_cc = src_dir.join("scanner.cc");',
        '    let schema_cc = src_dir.join("schema.generated.cc");',
        '    ',
        '    // Build parser with C compiler',
        '    let mut build = cc::Build::new();',
        '    build',
        '        .file(&parser_c)',
        '        .include(&src_dir)',
        '        .include(grammar_dir)',
        '        .warnings(false);',
        '    ',
        '    if scanner_c.exists() {',
        '        println!("cargo:rerun-if-changed={}", scanner_c.display());',
        '        build.file(&scanner_c);',
        '    }',
        '    ',
        '    build.compile(&format!("tree_sitter_{}", name.replace("-", "_")));',
        '    ',
        '    // If there are C++ files, compile them separately with C++ compiler',
        '    if scanner_cc.exists() || schema_cc.exists() {',
        '        let mut cpp_build = cc::Build::new();',
        '        cpp_build',
        '            .cpp(true)',
        '            .include(&src_dir)',
        '            .include(grammar_dir)',
        '            .warnings(false);',
        '        ',
        '        if scanner_cc.exists() {',
        '            println!("cargo:rerun-if-changed={}", scanner_cc.display());',
        '            cpp_build.file(&scanner_cc);',
        '        }',
        '        if schema_cc.exists() {',
        '            println!("cargo:rerun-if-changed={}", schema_cc.display());',
        '            cpp_build.file(&schema_cc);',
        '        }',
        '        ',
        '        cpp_build.compile(&format!("tree_sitter_{}_cpp", name.replace("-", "_")));',
        '    }',
        '    ',
        '    println!("cargo:rustc-link-lib=static=tree_sitter_{}", name.replace("-", "_"));',
        '}',
        '',
        'fn generate_ffi_module(grammars: &[(&str, &str, &str)]) {',
        '    let out_dir = env::var("OUT_DIR").unwrap();',
        '    let dest_path = Path::new(&out_dir).join("grammar_ffi.rs");',
        '    ',
        '    let mut content = String::new();',
        '    content.push_str("// Auto-generated by build.rs\n");',
        '    content.push_str("// FFI declarations for tree-sitter grammars\n\n");',
        '    content.push_str("use tree_sitter_language::LanguageFn;\n\n");',
        '    ',
        '    for (name, _, _) in grammars {',
        '        let fn_name = format!("tree_sitter_{}", name.replace("-", "_"));',
        '        content.push_str(&format!(r#"extern "C" {{ fn {}() -> *const (); }}"#, fn_name));',
        '        content.push_str("\n");',
        '    }',
        '    ',
        '    content.push_str("\n/// Get the language function for a grammar by name.\n");',
        '    content.push_str("pub fn get_language(name: &str) -> Option<tree_sitter::Language> {\n");',
        '    content.push_str("    match name {\n");',
        '    ',
        '    for (name, _, _) in grammars {',
        '        let fn_name = format!("tree_sitter_{}", name.replace("-", "_"));',
        '        content.push_str(&format!(r#"        "{}" => Some(unsafe {{ LanguageFn::from_raw({}) }}.into()),"#, name, fn_name));',
        '        content.push_str("\n");',
        '    }',
        '    ',
        '    content.push_str("        _ => None,\n");',
        '    content.push_str("    }\n");',
        '    content.push_str("}\n");',
        '    ',
        '    fs::write(&dest_path, &content).unwrap();',
        '    println!("cargo:rerun-if-changed=build.rs");',
        '}',
    ])
    
    return '\n'.join(lines)


def generate_registry_rs(grammars: dict):
    """Generate registry.rs content."""
    lines = [
        '//! Language registry for tree-sitter grammars.',
        '//!',
        '//! Manages available languages and provides language lookup by name or alias.',
        '//! Grammars are compiled from source during the build process.',
        '',
        'use std::collections::HashMap;',
        'use tree_sitter::Language;',
        '',
        '// Include the FFI bindings generated by build.rs',
        'include!(concat!(env!("OUT_DIR"), "/grammar_ffi.rs"));',
        '',
        '/// Registry containing all supported languages.',
        'pub struct LanguageRegistry {',
        '    /// Map from language name to tree-sitter Language',
        '    languages: HashMap<String, Language>,',
        '    /// Map from alias to canonical language name',
        '    aliases: HashMap<String, String>,',
        '}',
        '',
        'impl LanguageRegistry {',
        '    /// Create a new language registry with all supported languages.',
        '    pub fn new() -> Self {',
        '        let mut registry = Self {',
        '            languages: HashMap::new(),',
        '            aliases: HashMap::new(),',
        '        };',
        '        ',
        '        // Register all languages compiled from source',
        '        let languages = [',
    ]
    
    for name in sorted(grammars.keys()):
        lines.append(f'            ("{name}", "{name}"),')
    
    lines.extend([
        '        ];',
        '        ',
        '        for (name, ffi_name) in languages {',
        '            if let Some(lang) = get_language(ffi_name) {',
        '                registry.register(name, lang);',
        '            }',
        '        }',
        '        ',
        '        // Register common aliases',
        '        registry.register_aliases("javascript", &["js", "ecmascript"]);',
        '        registry.register_aliases("python", &["py"]);',
        '        registry.register_aliases("rust", &["rs"]);',
        '        registry.register_aliases("typescript", &["ts"]);',
        '        registry.register_aliases("cpp", &["c++", "cc", "cxx"]);',
        '        registry.register_aliases("bash", &["sh", "shell", "zsh"]);',
        '        registry.register_aliases("markdown", &["md", "mkd"]);',
        '        registry.register_aliases("yaml", &["yml"]);',
        '        registry.register_aliases("c-sharp", &["c#", "cs", "csharp"]);',
        '        registry.register_aliases("fsharp", &["f#", "fsharp"]);',
        '        registry.register_aliases("go", &["golang"]);',
        '        registry.register_aliases("ruby", &["rb"]);',
        '        registry.register_aliases("php", &["php3", "php4", "php5"]);',
        '        registry.register_aliases("perl", &["pl"]);',
        '        registry.register_aliases("java", &["jsp"]);',
        '        registry.register_aliases("scala", &["sc"]);',
        '        registry.register_aliases("kotlin", &["kt", "kts"]);',
        '        registry.register_aliases("swift", &["swiftlang"]);',
        '        registry.register_aliases("lua", &["lua54", "lua53", "lua51"]);',
        '        registry.register_aliases("haskell", &["hs"]);',
        '        registry.register_aliases("ocaml", &["ml"]);',
        '        registry.register_aliases("elixir", &["ex", "exs"]);',
        '        registry.register_aliases("erlang", &["erl"]);',
        '        registry.register_aliases("clojure", &["clj", "cljs"]);',
        '        registry.register_aliases("scheme", &["scm", "racket"]);',
        '        registry.register_aliases("r", &["rscript"]);',
        '        registry.register_aliases("julia", &["jl"]);',
        '        registry.register_aliases("dart", &["flutter"]);',
        '        registry.register_aliases("dockerfile", &["docker", "dockerignore"]);',
        '        registry.register_aliases("sql", &["mysql", "postgresql", "postgres", "sqlite"]);',
        '        registry.register_aliases("json", &["json5", "jsonc"]);',
        '        registry.register_aliases("xml", &["svg", "xsl", "xslt"]);',
        '        registry.register_aliases("toml", &["cargo_toml"]);',
        '        registry.register_aliases("ini", &["conf", "config", "properties"]);',
        '        registry.register_aliases("make", &["makefile", "mk"]);',
        '        registry.register_aliases("cmake", &["cmakelists"]);',
        '        registry.register_aliases("typescript", &["ts", "typescript"]);',
        '        registry.register_aliases("tsx", &["typescript-react", "typescriptreact"]);',
        '        registry.register_aliases("jsx", &["javascript-react", "javascriptreact", "react"]);',
        '        registry.register_aliases("objective-c", &["objc", "objectivec", "obj-c"]);',
        '        registry.register_aliases("objective-cpp", &["objcpp", "objectivecpp"]);',
        '        registry.register_aliases("scala", &["sc"]);',
        '        registry.register_aliases("perl", &["pl", "pm"]);',
        '        registry.register_aliases("powershell", &["ps1", "pwsh"]);',
        '        registry.register_aliases("php", &["php3", "php4", "php5", "php7"]);',
        '        ',
        '        registry',
        '    }',
        '    ',
        '    /// Register a language with its tree-sitter Language.',
        '    pub fn register(&mut self, name: &str, language: Language) {',
        '        self.languages.insert(name.to_lowercase(), language);',
        '    }',
        '    ',
        '    /// Register aliases for a language.',
        '    pub fn register_aliases(&mut self, canonical: &str, aliases: &[&str]) {',
        '        for alias in aliases {',
        '            self.aliases.insert(alias.to_lowercase(), canonical.to_lowercase());',
        '        }',
        '    }',
        '    ',
        '    /// Get a language by name or alias.',
        '    ///',
        '    /// Returns `Some(Language)` if found, `None` otherwise.',
        '    pub fn get_language(&self, name: &str) -> Option<Language> {',
        '        let name_lower = name.to_lowercase();',
        '        ',
        '        // Try direct lookup first',
        '        if let Some(lang) = self.languages.get(&name_lower) {',
        '            return Some(lang.clone());',
        '        }',
        '        ',
        '        // Try alias lookup',
        '        if let Some(canonical) = self.aliases.get(&name_lower) {',
        '            return self.languages.get(canonical).map(|l| l.clone());',
        '        }',
        '        ',
        '        None',
        '    }',
        '    ',
        '    /// Check if a language is supported.',
        '    pub fn is_supported(&self, name: &str) -> bool {',
        '        self.get_language(name).is_some()',
        '    }',
        '    ',
        '    /// Get list of all supported language names.',
        '    pub fn supported_languages(&self) -> Vec<&str> {',
        '        self.languages.keys().map(|s| s.as_str()).collect()',
        '    }',
        '}',
        '',
        'impl Default for LanguageRegistry {',
        '    fn default() -> Self {',
        '        Self::new()',
        '    }',
        '}',
        '',
        '#[cfg(test)]',
        'mod tests {',
        '    use super::*;',
        '    ',
        '    #[test]',
        '    fn test_registry_creation() {',
        '        let registry = LanguageRegistry::new();',
        '        assert!(registry.languages.len() > 0);',
        '    }',
        '    ',
        '    #[test]',
        '    fn test_get_language() {',
        '        let registry = LanguageRegistry::new();',
        '        ',
        '        // Test some common languages',
        '        assert!(registry.get_language("rust").is_some() || !registry.languages.contains_key("rust"));',
        '        assert!(registry.get_language("python").is_some() || !registry.languages.contains_key("python"));',
        '    }',
        '    ',
        '    #[test]',
        '    fn test_aliases() {',
        '        let registry = LanguageRegistry::new();',
        '        ',
        '        // Test alias lookup',
        '        if registry.languages.contains_key("javascript") {',
        '            assert!(registry.get_language("js").is_some());',
        '        }',
        '        if registry.languages.contains_key("python") {',
        '            assert!(registry.get_language("py").is_some());',
        '        }',
        '    }',
        '    ',
        '    #[test]',
        '    fn test_is_supported() {',
        '        let registry = LanguageRegistry::new();',
        '        ',
        '        // At least some languages should be supported',
        '        assert!(registry.languages.len() > 0);',
        '    }',
        '}',
    ])
    
    return '\n'.join(lines)


def main():
    print("Reading grammar_info.json...")
    with open(GRAMMAR_INFO, 'r') as f:
        all_grammars = json.load(f)
    
    print(f"Found {len(all_grammars)} grammars in grammar_info.json")
    
    # Filter to common languages if specified
    if COMMON_LANGUAGES is not None:
        grammars = {k: v for k, v in all_grammars.items() if k in COMMON_LANGUAGES}
        print(f"Filtered to {len(grammars)} common languages")
        skipped = set(all_grammars.keys()) - COMMON_LANGUAGES
        if skipped:
            print(f"Skipped {len(skipped)} languages: {', '.join(sorted(skipped)[:10])}...")
    else:
        grammars = all_grammars
        print("Using all grammars (no filter)")
    
    print("\nGenerating build.rs...")
    build_content = generate_build_rs(grammars)
    with open(BUILD_RS, 'w', encoding='utf-8') as f:
        f.write(build_content)
    print(f"  Written to {BUILD_RS}")
    
    print("\nGenerating registry.rs...")
    registry_content = generate_registry_rs(grammars)
    with open(REGISTRY_RS, 'w', encoding='utf-8') as f:
        f.write(registry_content)
    print(f"  Written to {REGISTRY_RS}")
    
    print("\nDone!")


if __name__ == "__main__":
    main()